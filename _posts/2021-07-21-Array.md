---
layout: post
toc: true
title: "Array"
categories: javascript
tags: [javascript]
author:
  - Jack
---



# Array 메서드(불변성 유지)
```javascript
const arr = [10, 20, 30, 40, 50]

// 불변성 유지가 안됨
arr.push(60)

// 불변성 유지
const arr1 = [10, 20, 30, 40, 50];
const arr2 = arr1.concat(60);
```

* [불변셩 유지 메서드](https://opentogether.tistory.com/105?category=865289)



# 배열 복사
```javascript
const arr = ["강아지", "고양이", "토끼", "소"];

const arr1 = arr.concat();
const arr2 = arr.slice();
const arr3 = [...arr];

const arr11 = arr.concat('호랑이', '말', '새')
const arr33 = [...arr, '도마뱀', '햄스터']
```
* Spread 문법은 배열을 복사할 때 1 레벨 깊이에서 효과적으로 동작합니다. 그러므로, 다음 예제와 같이 다차원 배열을 복사하는것에는 적합하지 않을 수 있습니다. (Object.assign() 과 전개 구문이 동일합니다)
  
  
  
# Rest 파라미터와 spread 연산자 차이
## Rest 파라미터
* Rest 파라미터는 Spread 연산자(...)를 사용하여 함수의 파라미터를 작성한 형태를 말한다. 즉, Rest 파라미터를 사용하면 함수의 파라미터로 오는 값들을 "배열"로 전달받을 수 있다.

```javascript
(Java에서 public static void func(String... strs){...} 이런식의 가변인자와 유사)

사용 방법은 파라미터 앞에 (...)을 붙인다.

function foo(...rest) {
  console.log(Array.isArray(rest)); // true
  console.log(rest); // [ 1, 2, 3, 4, 5 ]
}
foo(1, 2, 3, 4, 5);


* function foo(param1, param2, ...rest){~~} 처럼 앞에 파라미터는 일반적인 파라미터로 받을 수 있고 그 뒤부터는 Rest 파라미터로 받을 수 있다.

- 단, Rest파라미터는 항상 제일 마지막 파라미터로 있어야 한다. 예를들어 function foo(...rest, param1, param2){~}는 사용 불가능하다.
```

## arguments VS rest 파라미터

```javascript
var foo = function () {
  console.log(arguments);
};
foo(1, 2); // { '0': 1, '1': 2 }
```

* arguments는 유사 배열 객체고 rest는 배열
* 유사 배열 객체(array-like object)는 간단하게 순회가능한(iterable) 특징이 있고 length 값을 알 수 있는 특징
* arguments는 유사배열객체이기 때문에 Array 오브젝트의 메서드를 사용할 수 없다.
* Rest 파라미터를 사용하면 더 유연한 코드를 작성할 수 있는 것이기 때문에 Rest 파라미터 사용을 권장한다.


## 유사배열
```javascript
var array = [1, 2, 3];

array; // [1, 2, 3]

var nodes = document.querySelectorAll('div'); // NodeList [div, div, div, div, div, ...]
var els = document.body.children; // HTMLCollection [noscript, link, div, script, ...]

Array.isArray(array); // true
Array.isArray(nodes); // false
Array.isArray(els); // false

```

## 유사배열 형태
```javascript
var yoosa = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
};

```
* 키가 숫자고, length라는 속성을 가지고 있습니다. 
* 배열처럼 yoosa[0], yoosa[1], yoosa.length같은 것을 모두 활용할 수 있습니다.
* 배열과 유사배열을 구분해야 하는 이유는, 유사배열의 경우 배열의 메서드를 쓸 수 없기 때문입니다.


### 유사배열에서 배열의 메서드 사용하는 방법
```javascript

1. Array.prototype.forEach.call(nodes, function(el) { console.log(el); });

2. [].forEach.call(els, function(el) { console.log(el); });

3. Array.from(nodes).forEach(function(el) { console.log(el) });
```



## spread 연산자
* Spread 연산자는 연산자의 대상 배열 또는 이터러블(iterable)을 "개별" 요소로 분리한다.

```javascript
// 배열
console.log(...[1, 2, 3]); // -> 1, 2, 3
 
// 문자열
console.log(...'Helllo');  // H e l l l o
 
// Map과 Set
console.log(...new Map([['a', '1'], ['b', '2']]));  // [ 'a', '1' ] [ 'b', '2' ]
console.log(...new Set([1, 2, 3]));  // 1 2 3
```

* 이터러블(iterable)은 Array, String, Map, Set, DOM구조다.



## Rest와 spread 연산자 차이 1
* Rest는 함수 선언문의 파라미터에 Spread(...)연산자를 이용해서 받으면 가변인자를 받아 배열로 만들어서 사용하는 것이고, 함수 호출문의 파라미터에 Spread(...)연산자를 이용해서 호출하면 배열이 해당 매개변수로 각각 매핑되는 것은 다르다.

```javascript
//Rest
function foo(param, ...rest) {
  console.log(param); // 1
  console.log(rest);  // [ 2, 3 ]
}
foo(1, 2, 3);
 
//Spread호출
function bar(x, y, z) {
  console.log(x); // 1
  console.log(y); // 2
  console.log(z); // 3
}
bar(...[1, 2, 3]);
```

## Rest와 spread 연산자 차이 2
```javascript
또한 Rest에서는 선언에서 Spread연산자를 제일 뒤에만 써야하지만, Spread호출에서는 중간중간 사용해도 상관없다.

* 배열에서 사용하는 방법 (가독성UP)

//ES5
var arr = [1, 2, 3];
console.log(arr.concat([4, 5, 6])); // [ 1, 2, 3, 4, 5, 6 ]
 
// ES6
const arr = [1, 2, 3];
// ...arr은 [1, 2, 3]을 개별 요소로 분리한다
console.log([...arr, 4, 5, 6]); // [ 1, 2, 3, 4, 5, 6 ]

```


## 객체에서 쓰는 spread 연산자
```javascript
const o1 = { x: 1, y: 2 };
const o2 = { ...o1, z: 3 };
console.log(o2); // { x: 1, y: 2, z: 3 }
 
const target = { x: 1, y: 2 };
const source = { z: 3 };
// Object.assign를 사용하여도 동일한 작업을 할 수 있다.
// Object.assign은 타깃 객체를 반환한다
console.log(Object.assign(target, source)); // { x: 1, y: 2, z: 3 }

```


# 구조 분해 할당
* 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식입니다.

```javascript
var a, b, rest;
[a, b] = [10, 20];
console.log(a); // 10
console.log(b); // 20

[a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a); // 10
console.log(b); // 20
console.log(rest); // [30, 40, 50]

({ a, b } = { a: 10, b: 20 });
console.log(a); // 10
console.log(b); // 20


// Stage 4(finished) proposal
({a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40});
console.log(a); // 10
console.log(b); // 20
console.log(rest); // {c: 30, d: 40}
```

## 일부 반환값 무시하기
```javascript
function f() {
  return [1, 2, 3];
}

var [a, , b] = f();

console.log(a); // 1
console.log(b); // 3
```

## 변수에 배열의 나머지를 할당하기
```javascript
var [a, ...b] = [1, 2, 3];

console.log(a); // 1
console.log(b); // [2, 3]
```


# 참조
* [정아마추어](https://jeong-pro.tistory.com/117)
