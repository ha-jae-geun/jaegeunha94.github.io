---
layout: post
toc: true
title: "Pattern"
categories: javascript
tags: [javascript]
author:
  - Jack
---

# 생성자 함수
* new 연산자와 함께 호출하며 사용하는 객체(인스턴스)를 생성하는 함수

```javascript
const test = new Test(1);
```

* 전달된 인수를 프로퍼티의 초기값으로 할당하여 인스턴스를 초기화한다.

```javascript
function Circle(radius) {
  this.getArea = function() {
    return Math.PI * this.radius ** 2;
  }
}

const circle1 = new Circle(1)
const circle2 = new Circle(2)

```

* Circle 생성자는 인스턴스를 생성할 때마다 getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유하여 메모리 낭비가 일어난다.



# 프로토타입 패턴 장점
* 모든 함수는 prototype 프로퍼티를 가집니다.
* 이 프로퍼티는 해당 참조 타입의 인스턴스가 가져야 할 프로퍼티와 메소드를 담고 있는 객체입니다.
* 프로토타입의 프로퍼티와 메소드는 객체 인스턴스 전체에서 공유된다는 점이 이 패턴의 장점입니다.



## 생성자 패턴과 프로토타입 패턴의 조합
* 가장 널리 쓰이는 방법입니다.
* 생성자 패턴으로 인스턴스 프로퍼티를 정의하고 프로토타입 패턴으로 메소도와 공유 프로퍼티를 정의하는 방법입니다.
* 모든 인스턴스는 자신만의 인스턴스 프로퍼티를 가질 수 있고, 참조 방식을 통해 메소드는 공유하므로 메모리를 절약할 수 있습니다.
* 또한, 생성자에 매개변수를 전달할 수도 있어서 두 패턴의 장점만 취한 패턴이라고 말할 수 있다.  
  
```javascript
function Person(name, age){
    this.name = name;
    this.age = age;
}

Person.prototype = {
    constructor : Person
    sayName : function(){
        console.log(this.name);
    }
};
```


# ES5 프로토타입 패턴 
```javascript
var Shape = function (id, x, y) {
   this.id = id;
   this.move(x, y);
};
Shape.prototype.move = function (x, y) {
   this.x = x;
   this.y = y;
};
 
```  

## ES6 프로토타입 패턴
```javascript

class Shape {
  constructor (id, x, y) {
    this.id = id
    this.move(x, y)
  }
  move (x, y) {
    this.x = x
    this.y = y
  }
}
```



# 프로토타입 프로퍼티 제거 예제
```javascript
function Person() {}

Person.prototype.name = 'jaegeun'

var person1 = new Person();

person1.name = "jg"

alert(person1.name)

delete person1.name;

alert(person1.name)

```
