---
layout: post
toc: true
title: "Pattern"
categories: javascript
tags: [javascript]
author:
  - Jack
---

# 객체 리터럴에 의한 객체 생성 방식의 문제점
```javascript
const circle1 = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius
  }
}

const circle2 = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius
  }
}
```  
* 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하므로 비효율적


# 생성자 함수
* 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.
* new 연산자와 함께 호출하며 사용하는 객체(인스턴스)를 생성하는 함수
  * 생성자 함수에 의해 성성된 객체를 인스턴스라 한다.

```javascript
const test = new Test(1);
```

* 전달된 인수를 프로퍼티의 초기값으로 할당하여 인스턴스를 초기화한다.
* 프로퍼티와 메서드는 this 객체에 직접적으로 할당
* return문이 없다.
* * new 없이 호출하면 프로퍼티, 메서드는 window에 추가

```javascript
function Circle(radius) {
  this.getArea = function() {
    return Math.PI * this.radius ** 2;
  }
}

const circle1 = new Circle(1)
const circle2 = new Circle(2)

circle1.getArea == circle2.getArea // false

```

* Circle 생성자는 인스턴스를 생성할 때마다 getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유하여 메모리 낭비가 일어난다.


# 함수의 내부 메서드 [[Call]]과 [[Construct]]
자바스크립트의 함수는 객체이므로 일반 객체처럼 동작할 수 있다.
함수는 일반 객체의 내부 슬롯과 내부 메서드들을 모두 가지고 있기 때문이다.

함수는 객체와 다르게 호출할 수 있는데,
함수가 객체와 다르게 [[Call]]과 [[Construct]] 내부 메서드를 가지고 있기 때문이다.

함수가 일반 함수로 호출되면 [[Call]] 내부 메서드가 호출되고
new 연산자와 함께 생성자 함수로 호출되면 [[Construct]] 내부 메서드가 호출된다.

[[Call]] 내부 메서드를 갖는 함수를 callable이라고 한다.
callable은 호출할 수 있는 함수를 뜻하며, 모든 함수는 callable이다.

[[Conastruct]] 내부 메서드를 갖는 함수를 constructor
갖지 않는 함수를 non-constructor 라고 한다.
constructor는 생성자 함수로 호출할 수 있는 함수를 뜻한다.


# constructor와 non-constructor
* 자바스크립트엔진은 함수정의를 평가하여 함수객체를 생성할때 함수정의 방식에 따라 함수를 constructor와 non-constructor로 구분한다.

* constructor : 함수 선언문, 함수 표현식, 클래스
* non-constructor : 메서드(es6 메서드 축약표현), 화살표함수
* 여기서 주의해야할것이 ECMAScript 사양에서 메서드로 인정하는 범위가 일반적인 의미의 메서드가 아니라 es6의 메서드 축약표현만을 의미한다는 것이다.

```javascript
// 일반 함수 정의: 함수 선언문, 함수 표현식
function foo() {}
const bar = function () {};
// 프로퍼티 x의 값으로 할당된 것은 일반 함수로 정의된 함수다. 이는 메서드로 인정하지 않는다.
const baz = {
 x: function () {}
};

// 일반 함수로 정의된 함수만이 constructor이다.
new foo();   // -> foo {}
new bar();   // -> bar {}
new baz.x(); // -> x {}

// 화살표 함수 정의
const arrow = () => {};

new arrow(); // TypeError: arrow is not a constructor

// 메서드 정의: ES6의 메서드 축약 표현만 메서드로 인정한다.
const obj = {
 x() {}
};

new obj.x(); // TypeError: obj.x is not a constructor
```



# 프로토타입 패턴 장점
* 모든 함수는 prototype 프로퍼티를 가집니다.
* 이 프로퍼티는 해당 참조 타입의 인스턴스가 가져야 할 프로퍼티와 메소드를 담고 있는 객체입니다.
* 프로토타입의 프로퍼티와 메소드는 객체 인스턴스 전체에서 공유된다는 점이 이 패턴의 장점입니다.

```javascript
function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getArea = function() {
  return Math.PI * this.radius ** 2
}

const circle1 = new Circle(1)
const circle2 = new Circle(2)

// 프로토타입 Circle.prototype으로 부터 getArea 메서드를 상속받는다.
// Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다.
console.log(circle1.getArea === circle2.getArea); // true
```


## 생성자 패턴과 프로토타입 패턴의 조합
* 가장 널리 쓰이는 방법입니다.
* 생성자 패턴으로 인스턴스 프로퍼티를 정의하고 프로토타입 패턴으로 메소도와 공유 프로퍼티를 정의하는 방법입니다.
* 모든 인스턴스는 자신만의 인스턴스 프로퍼티를 가질 수 있고, 참조 방식을 통해 메소드는 공유하므로 메모리를 절약할 수 있습니다.
* 또한, 생성자에 매개변수를 전달할 수도 있어서 두 패턴의 장점만 취한 패턴이라고 말할 수 있다.  
  
```javascript
function Person(name, age, job) {
  this.name = name;
}

Person.prototype = {
  constructor: Person,
  sayName: function () {
    alert(this.name);
  }
}
```


# ES5 프로토타입 패턴 
```javascript
var Circle = function (id, x, y) {
   this.id = id;
   this.move(x, y);
};
Circle.prototype.move = function (x, y) {
   this.x = x;
   this.y = y;
};
 
```  

## ES6 프로토타입 패턴
```javascript

class Circle {
  constructor (id, x, y) {
    this.id = id
    this.move(x, y)
  }
  move (x, y) {
    this.x = x
    this.y = y
  }
}
```

* 클래스 몸체에서 정의한 메서드는 prototype ㅡㅍ로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.

# 프로토타입 프로퍼티 제거 예제
```javascript
function Person() {}

Person.prototype.name = 'jaegeun'

var person1 = new Person();

person1.name = "jg"

alert(person1.name)

delete person1.name;

alert(person1.name)

```
