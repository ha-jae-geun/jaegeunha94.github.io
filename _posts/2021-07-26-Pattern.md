---
layout: post
toc: true
title: "Pattern"
categories: javascript
tags: [javascript]
author:
  - Jack
---

# 객체 리터럴에 의한 객체 생성 방식의 문제점
```javascript
const circle1 = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius
  }
}

const circle2 = {
  radius: 5,
  getDiameter() {
    return 2 * this.radius
  }
}
```  
* 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하므로 비효율적


# 생성자 함수
* 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.
* new 연산자와 함께 호출하며 사용하는 객체(인스턴스)를 생성하는 함수
  * 생성자 함수에 의해 생성된 객체를 인스턴스라 한다.

```javascript
const test = new Test(1);
```

* 전달된 인수를 프로퍼티의 초기값으로 할당하여 인스턴스를 초기화할 수 있다.
* 프로퍼티와 메서드는 this 객체에 직접적으로 할당
* new 없이 호출하면 프로퍼티, 메서드는 window에 추가


## 생성자 함수의 단점
```javascript
function Circle(radius) {
  this.getArea = function() {
    return Math.PI * this.radius ** 2;
  }
}

const circle1 = new Circle(1)
const circle2 = new Circle(2)

circle1.getArea == circle2.getArea // false

```

* Circle 생성자는 인스턴스를 생성할 때마다 getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유하여 메모리 낭비가 일어난다.




# 프로토타입 패턴
* 모든 함수는 prototype 프로퍼티를 가집니다.
* 이 프로퍼티는 해당 참조 타입의 인스턴스가 가져야 할 프로퍼티와 메소드를 담고 있는 객체입니다.
* 프로토타입의 프로퍼티와 메소드는 객체 인스턴스 전체에서 공유된다는 점이 이 패턴의 장점입니다.

```javascript
function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getArea = function() {
  return Math.PI * this.radius ** 2
}

const circle1 = new Circle(1)
const circle2 = new Circle(2)

// 프로토타입 Circle.prototype으로 부터 getArea 메서드를 상속받는다.
// Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다.

console.log(circle1.getArea === circle2.getArea); // true
```


# 프로토타입 패턴 주의할 점
```javascript
function Person() {}

Person.prototype = {
  friends : ["jaegeun", "test"]
}

var person1 = new Person();
var person2 = new Person();

person1.friends.push("Van")
console.log(person2.friends)

```  

* 프로토타입에 존재하는 프로퍼티는 모든 인스턴스에서 공유됩니다.
  * 원시타잉은 문제가 되지 않지만, 참조타입은 이것이 문제가 됩니다.


## 해결
```javascript
function Person() {
  this.friends = ["jaegeun", "test"]
}

Person.prototype = {
  constructor: Person
}

var person1 = new Person();
var person2 = new Person();

console.log(person1.friends === person2.friends);
```



# ES5 프로토타입 패턴 
```javascript
var Circle = function (id, x, y) {
   this.id = id;
   this.move(x, y);
};
Circle.prototype.move = function (x, y) {
   this.x = x;
   this.y = y;
};
 
```  

## ES6 프로토타입 패턴
```javascript

class Circle {
  constructor (id, x, y) {
    this.id = id
    this.move(x, y)
  }
  move (x, y) {
    this.x = x
    this.y = y
  }
}
```

* 클래스 몸체에서 정의한 메서드는 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.



# 생성자 패턴과 프로토타입 패턴의 조합
* 가장 널리 쓰이는 방법입니다.
* 생성자 패턴으로 인스턴스 프로퍼티를 정의하고 프로토타입 패턴으로 메소도와 공유 프로퍼티를 정의하는 방법입니다.
* 모든 인스턴스는 자신만의 인스턴스 프로퍼티를 가질 수 있고, 참조 방식을 통해 메소드는 공유하므로 메모리를 절약할 수 있습니다.
* 또한, 생성자에 매개변수를 전달할 수도 있어서 두 패턴의 장점만 취한 패턴이라고 말할 수 있다.  
  
```javascript
function Person(name, age, job) {
  this.name = name;
}

Person.prototype = {
  constructor: Person,
  sayName: function () {
    alert(this.name);
  }
}
```

# 프로토타입 프로퍼티 제거 예제
```javascript
function Person() {}

Person.prototype.name = 'jaegeun'

var person1 = new Person();

person1.name = "jg"

alert(person1.name)

delete person1.name;

alert(person1.name)

```





# 함수의 내부 메서드 [[Call]]과 [[Construct]]
자바스크립트의 함수는 객체이므로 일반 객체처럼 동작할 수 있다.
함수는 일반 객체의 내부 슬롯과 내부 메서드들을 모두 가지고 있기 때문이다.

함수는 객체와 다르게 호출할 수 있는데,
함수가 객체와 다르게 [[Call]]과 [[Construct]] 내부 메서드를 가지고 있기 때문이다.

함수가 일반 함수로 호출되면 [[Call]] 내부 메서드가 호출되고
new 연산자와 함께 생성자 함수로 호출되면 [[Construct]] 내부 메서드가 호출된다.

[[Call]] 내부 메서드를 갖는 함수를 callable이라고 한다.
callable은 호출할 수 있는 함수를 뜻하며, 모든 함수는 callable이다.

[[Conastruct]] 내부 메서드를 갖는 함수를 constructor
갖지 않는 함수를 non-constructor 라고 한다.
constructor는 생성자 함수로 호출할 수 있는 함수를 뜻한다.


# constructor와 non-constructor
* 자바스크립트엔진은 함수정의를 평가하여 함수객체를 생성할때 함수정의 방식에 따라 함수를 constructor와 non-constructor로 구분한다.

* constructor : 함수 선언문, 함수 표현식, 클래스
* non-constructor : 메서드(es6 메서드 축약표현), 화살표함수
* 여기서 주의해야할것이 ECMAScript 사양에서 메서드로 인정하는 범위가 일반적인 의미의 메서드가 아니라 es6의 메서드 축약표현만을 의미한다는 것이다.

```javascript
// 일반 함수 정의: 함수 선언문, 함수 표현식
function foo() {}
const bar = function () {};
// 프로퍼티 x의 값으로 할당된 것은 일반 함수로 정의된 함수다. 이는 메서드로 인정하지 않는다.
const baz = {
 x: function () {}
};

// 일반 함수로 정의된 함수만이 constructor이다.
new foo();   // -> foo {}
new bar();   // -> bar {}
new baz.x(); // -> x {}

// 화살표 함수 정의
const arrow = () => {};

new arrow(); // TypeError: arrow is not a constructor

// 메서드 정의: ES6의 메서드 축약 표현만 메서드로 인정한다.
const obj = {
 x() {}
};

new obj.x(); // TypeError: obj.x is not a constructor
```

* 일반적으로 프로퍼티의 값인 함수는 모두 메소드로 통칭한다. 하지만 ECMAScript 사양에서 “메소드 정의”란 ES6의 메소드 축약 표현만을 의미한다. 다시 말해 함수가 어디에 할당되어 있는지에 따라 메소드 정의인지를 판단하는 것이 아니라 함수 정의 방식에 따라 함수의 종류를 구분한다.
* 위 예제와 같이 일반 함수로 정의된 함수만이 constructor이다. 함수의 종류가 Arrow, Method인 함수는 non-constructor가 된다. 즉, 일반 함수로 정의된 함수만이 생성자 함수로서 호출될 수 있다. method와 화살표 함수는 [[Construct]]가 없다. 즉, non-constructor로 new 연산자로 생성할 수 없다. 그래서 축약표현으로 표현한 것은 스펙상 메소드이기 때문에 new 연산자로 생성자 함수를 만들 수 없다.
