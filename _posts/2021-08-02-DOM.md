---
layout: post
toc: true
title: "DOM"
categories: javascript
tags: [javascript]
author:
  - Jack
---

# DOM
* 텍스트 파일로 만들어져 있는 웹 문서를 브라우저에 렌더링하려면 웹 문서를 브라우저가 이해할 수 있는 구조로 메모리에 올려야 한다.
* 브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라 한다. 
* 즉 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계를 표현할 수 있는 트리 구조로 구성한 것이 DOM이다. 
* 이 DOM은 자바스크립트를 통해 동적으로 변경할 수 있으며 변경된 DOM은 렌더링에 반영된다.


# DOM tree
* DOM tree는 브라우저가 HTML 문서를 로드한 후 파싱하여 생성하는 모델을 의미한다. 객체의 트리로 구조화되어 있기 때문에 DOM tree라 부른다.



# 스크립트 동적로딩
```javascript
function loadScript(url) {
    var script = document.createElement("script")
    script.type = "text/javascript";
    script.src = url
    document.body.appencChild(script);
}
```

## 스크립트 요소에 코드 삽입(익스플로어에서 동작 안함)
```javascript
var script = document.createElement("script");
script.type = "text/javascript";
script.appendChild(document.createTextNode("function sayHi() {alert('hi');}")
document.body.appendChild(script);

```

* 익스플로어에서는 script 요소를 특별 취급하여 정규 DOM 메서드로 이 요소의 자식 노드에 접근할 수 없다.



## 스크립트 코드 삽입(사파리 초기버전 지원)
```javascript
var script = document.createElement("script");
script.type="textjavascript";
var code = "function sayHi() {alert("hi');}";
try {
    script.appencChild(document.createTextNode("code"));
} catch(e) {
    script.text = "code"
}
document.body.appendChild(script)
```


# 동적 스크립트 로딩
  ```javascript
  
    var scriptLoading = function (obj, i, func, errorcallback) {
        var script = obj.getScript();
        var scriptLen = script.length;

        if (scriptLen == 0) {
            errorcallback();
            return;
        }

        var callback = function () {
            if (i == scriptLen - 1) {
                func()
            }
            scriptLoading(obj, ++i, func, errorcallback);
        };

        var head = document.getElementsByTagName("head")[0];
        var testScript = document.createElement("script");
        testScript.src = obj.getPath() + script[i];

        if (testScript.addEventListener) {
            testScript.addEventListener("load", callback);
        }
        else if (testScript.readyState) {
            testScript.onreadystatechange = function () {
                if (this.readyState == "loaded" || this.readyState == "complete") {
                    callback();
                }
            };
        } 

        head.appendChild(testScript);
    };

  ```
  
  # [addEventListener can i use](https://caniuse.com/?search=addEventListener)
  

# DOM 이벤트


# onLoad
* 문서의 모든 콘텐츠(images, script, css, etc)가 로드된 후 발생하는 이벤트이다

```javascript
window.onload = function() {
//실행될 코드
}
```

* 문서에 포함된 모든 콘텐츠가 로드된 후에 실행되기에 불필요한 로딩시간이 추가될 수 있다.
* 동일한 문서에 오직 onload는 하나만 존재해야 한다.
* 중복될 경우, 마지막 선언이 실행된다.
* 외부 라이브러리에서 이미 선언된 경우 이를 찾아 하나로 합치는 과정이 필요하다.

```javascript

// 아래와 같이 사용된 경우, window.onload로 지정된 것은 무시된다.
<body onload="실행될 코드">


window 객체뿐만 아니라 원하는 객체(object)가 로드되었을때 실행될 코드를 설정할 수 있다.
document.getElementById("myFrame").onload = function() {
  //실행될 코드
}

// 이벤트를 직접 연결할 수도 있다.
window.addEventListener('load', function(){
  //실행될 코드
});


// jQuery
$(window).load( function() { //실행될 코드 })

```

# DOMContentLoaded
* HTML과 script가 로드된 시점에 발생하는 이벤트이다.

```javascript
window.addEventListener('DOMContentLoaded', function(){
//실행될 코드
})
```
* onload 이벤트보다 먼저 발생한다. 빠른 실행속도가 필요할때 적합하다.
* IE8 이하에서는 지원하지 않는다.


## DOMContentLoaded 예제
```javascript
<script>
  function ready() {
    alert('DOM이 준비되었습니다!');

    // 이미지가 로드되지 않은 상태이기 때문에 사이즈는 0x0입니다.
    alert(`이미지 사이즈: ${img.offsetWidth}x${img.offsetHeight}`);
  }

  document.addEventListener("DOMContentLoaded", ready);
</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">
```  

* DOMContentLoaded 핸들러는 문서가 로드되었을 때 실행 됩니다.
* 따라서 핸들러 아래쪽에 위치한 img태그 뿐만 아니라 모든 요소에 접근 할 수 있습니다.
* 하지만 이미지가 로드되는 것을 기다리지 않기 때문에 alert 창엔 이미지 사이즈가 0이라고 뜹니다.


## DOMContentLoaded 지연

* [스크립트 로딩](https://blog.asamaru.net/2017/05/04/script-async-defer/)
* 브라우저는 HTML 문서를 처리하는 도중에 <script>태그를 만나면, DOM 트리 구성을 멈추고 <script>를 실행합니다.
* 스크립트실행이 끝난 후에야 나머지 HTML 문서를 처리합니다.
* 따라서, DOMContentLoaded 이벤트 역시 <script> 안에 있는 스크립트가 처리되고 난 후에 발생합니다.

```javascript
<script>
  document.addEventListener("DOMContentLoaded", () => {
    alert("DOM이 준비되었습니다!");
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"></script>

<script>
  alert("라이브러리 로딩이 끝나고 인라인 스크립트가 실행되었습니다.");
</script>
```     
 
* 예시를 실행하면 "라이브러리 로딩이 끝나고..."가 먼저 보인 후 "DOM이 준비되었습니다!"가 출력됩니다.
* 스크립트가 모두 실행되고 난 후에 DOMContentLoaded 이벤트가 발생합니다.

    
## DOMContentLoaded를 막지 않는 스크립트
1. async 속성이 있는 스크립트는 DOMContentLoaded를 막지 않습니다.
2. document.createElement('script')로 동적으로 생성되고 웹페이지에 추가된 스크립트는 DOMContentLoaded를 막지 않습니다.
  
  
## ie8 이하에서 DOMContentLoaded 
```javascript
// Mozilla, Opera, Webkit 
if (document.addEventListener) { 
  document.addEventListener("DOMContentLoaded", function () { 
    document.removeEventListener("DOMContentLoaded", arguments.callee, false); 
    domReady(); 
   }, false);
 }

```
  
## document.readyState
1. loading
  * document 로딩 중.
2. interactive
  * 문서의 로딩은 끝이 나고 해석 중 이지만  images, stylesheets, frames과 같은 하위 자원들은 로딩되고 있는 상태이다.
3. complete
  * 문서와 모든 하위 자원들의 로드가 완료된 상태이다. 이 상태는 load  이벤트가 발생되기 직전 상태이다.

```javascript

// 1. DOMContentLoaded 이벤트의 대안으로 readystatechange
// DOMContentLoaded 이벤트의 대안
  
document.onreadystatechange = function () {
  if (document.readyState === 'interactive') {
    initApplication();
  }
}
  
  
//2. 로드 이벤트의 대안으로 readystatechange
//로드 이벤트의 대안
document.onreadystatechange = function () {
  if (document.readyState === 'complete') {
    initApplication();
  }
}  
```
  
  
# jQuery ready
* 자바스크립트의 DOM 트리가 준비되었을때의 시점을 컨트롤하는 메소드로 DOMContentLoaded의 jQuery 버전이라고 할 수 있다.

```javascript
$("document").ready(function() {
  // DOM이 준비됨
  // 이후의 코드는 여기에 작성됨
});
또는

$(function() {
  // DOM이 준비됨
  // 이후의 코드는 여기에 작성됨
});
```  

* onload 이벤트보다 먼저 발생한다. 
* 즉, 문서의 모든 자원이 다운로드되었을때 발생하는 onload와 달리 DOM 트리만 완성되면 바로 발생하므로 빠른 실행속도가 필요할때 적합하다.
* 여러번 사용되면 선언 순서에 따라 순차적으로 실행된다.


# 실행 순서 비교
```javascript
<script>
  log('초기 readyState:' + document.readyState);

  document.addEventListener('readystatechange', () => log('readyState:' + document.readyState));
  document.addEventListener('DOMContentLoaded', () => log('DOMContentLoaded'));

  window.onload = () => log('window onload');
</script>

<iframe src="iframe.html" onload="log('iframe onload')"></iframe>

<img src="http://en.js.cx/clipart/train.gif" id="img">
<script>
  img.onload = () => log('img onload');
</script>
```

* 실행 결과는 다음과 같습니다.
  
* [1] initial readyState:loading
* [2] readyState:interactive
  [2] DOMContentLoaded
  [3] iframe onload
  [4] img onload
  [4] readyState:complete
  [4] window onload

  * 대괄호 안에 있는 숫자는 실제 해당 로그가 출력되기까지 걸린 시간을 나타냅니다. 같은 숫자는 1 미리 초 오차 범위 내에서 동시에 실행된 이벤트라는 것을 의미합니다.
  * document.readyState는 DOMContentLoaded가 실행되기 바로 직전에 interactive가 됩니다. 따라서 DOMContentLoaded와 interactive는 같은 상태를 나타낸다고 볼 수 있습니다.
  * document.readyState는 iframe, img를 비롯한 리소스 전부가 로드되었을 때 complete가 됩니다. 위 예시에서 우리는 readyState의 값이 img.onload와 window.onload가 실행된 시점과 거의 동일한 시점에 complete로 바뀌었다는 것을 확인할 수 있습니다. 
  * readyState의 값이 complete로 바뀐다는 것은 window.onload가 실행된다는 것과 동일한 의미입니다. 이 둘의 차이점은 window.onload는 다른 load 핸들러가 전부 실행된 후에야 동작한다는 것에 있습니다.
  

# [실행 순서 비교](http://jsfiddle.net/HgJ33/)
```javascript

(function(){ console.log(1); })();  // 1

$(function(){ console.log(2); });    // 2

$(document).ready(function(){ console.log(3); });  // 3

window.onload = console.log(4);  // 4

```
* 실행순서는 1번 -> 4번 -> 2번 -> 3번
* :위와 같은 순서로 코드를 기술하였다고 할 때 실행순서를 생각해보면, '3번 -> 1번 -> 2번 -> 4번' 순으로 실행됨. 이유는 1번은 읽히는 시점에서 바로 1번이 실행되고(1번 코드가 맨 마지막에 기술되었다고 해도 가장 먼저 실행됨) 2번과 3번은 document(HTML문서)의 HTML태그 뿐만 아니라 CSS 자바스크립트 등을 포함한 처음부터 끝까지를 웹브라우저가 모두 인식한 다음에 실행됨(이미지 등의 리소스 다운로드는 기다리지 않음)
* 2번과 3번은 실행시기가 동일하지만 (동일한함수) 2번을 위에 작성했다는 가정하였을 때 2번이 먼저 실행된다고 봄
* 4번은 document(HTML문서) 뿐만아니라 이미지 등의 리소스 다운로드를 전부 기다렸다가 실행됨

  
  
# 출처
* [WEBDIR](https://webdir.tistory.com/515)
